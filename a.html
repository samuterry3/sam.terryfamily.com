<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platform Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #333;
        }
        #game {
            background: #87CEEB;
            position: relative;
        }
        .player {
            width: 30px;
            height: 30px;
            background: #ff0000;
            position: absolute;
            border-radius: 5px;
        }
        .platform {
            background: #4CAF50;
            position: absolute;
        }
        .level-text {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-family: Arial;
        }
        .coin-text {
            position: absolute;
            top: 60px;
            left: 20px;
            color: gold;
            font-size: 24px;
            font-family: Arial;
        }
    </style>
</head>
<body>
    <div class="level-text">Level: <span id="level-display">1</span></div>
    <div class="coin-text">Coins: <span id="coin-display">0</span></div>
    <canvas id="game" width="800" height="400"></canvas>
    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const levelDisplay = document.getElementById('level-display');
        const coinDisplay = document.getElementById('coin-display');

        let currentLevel = 1;
        let coins = 0;

        const player = {
            x: 50,
            y: 200,
            width: 30,
            height: 30,
            speed: 5,
            jumpForce: 12,
            gravity: 0.5,
            velocityY: 0,
            isJumping: false
        };

        class Coin {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 15;
                this.height = 15;
                this.collected = false;
            }
        }

        // Function to generate level data
        function generateLevelData(levelNum) {
            const platforms = [{ x: 0, y: 350, width: canvas.width, height: 50 }]; // Ground platform
            const coins = [];
            // Number of extra platforms increases with level number
            const numExtraPlatforms = 2 + Math.floor((levelNum - 1) / 5); // e.g., L1-5: 2, L6-10: 3, etc.

            let currentX = 100; // Starting X for the first custom platform

            for (let i = 0; i < numExtraPlatforms; i++) {
                // Platform width varies pseudo-randomly based on level and platform index
                const pWidth = 100 + ((levelNum * 3 + i * 7) % 50); // Width between 100 and 149

                // Platform X position: progresses across the screen
                // Gap varies pseudo-randomly
                currentX += 60 + ((levelNum * 5 + i * 11) % 70); // Gap between 60 and 129
                
                // Ensure platform is within canvas bounds
                if (currentX + pWidth >= canvas.width - 30) {
                    currentX = canvas.width - 30 - pWidth;
                }
                if (currentX < 20) currentX = 20; // Ensure not too far left

                // Platform Y position: varies pseudo-randomly
                let pY = 300 - ((levelNum * 10 + i * 25) % 220); // Base Y between 80 (300-220) and 300 (300-0)
                
                if (pY < 80) { // If too high, bring it down a bit
                    pY = 80 + ((levelNum + i * 2) % 30); // Y becomes 80-109
                }
                if (pY > 350 - 20 - 20) { // If too low (colliding with ground or too close)
                    pY = 350 - 40 - ((levelNum + i * 3) % 40); // Y becomes 271 - 310
                }


                platforms.push({ x: currentX, y: pY, width: pWidth, height: 20 });

                // Add a coin on this platform
                coins.push(new Coin(currentX + pWidth / 2 - 7.5, pY - 30));
                
                // Add a second coin on the platform for some levels/platforms
                if ((levelNum + i) % 3 === 0) {
                     coins.push(new Coin(currentX + 20 + ((i*5)% (pWidth-40)), pY - 30));
                }
                
                currentX += pWidth; // Advance currentX for the next platform's gap calculation
            }
            
            // Add some coins on the ground, number depends on level
            const numGroundCoins = 1 + Math.floor(levelNum / 6); // 1 to 5 ground coins
            for(let k=0; k < numGroundCoins; k++) {
                const coinX = 150 + k * 80 + ((levelNum*7)%40);
                if (coinX < canvas.width - 50) { // Ensure coins are not too close to finish line
                    coins.push(new Coin(coinX, 320));
                }
            }

            // Standard finish line for all generated levels
            const finishLine = { x: canvas.width - 60, y: 350 - 70, width: 10, height: 70 };

            return { platforms, coins, finishLine };
        }

        const levels = [
            // Level 1 - Basic platforms
            {
                platforms: [
                    { x: 0, y: 350, width: 800, height: 50 },
                    { x: 300, y: 250, width: 200, height: 20 },
                    { x: 100, y: 150, width: 200, height: 20 }
                ],
                coins: [
                    new Coin(350, 220),
                    new Coin(400, 220),
                    new Coin(150, 120)
                ],
                finishLine: { x: canvas.width - 60, y: 350 - 70, width: 10, height: 70 } // x, y (top-left), width, height
            },
            // Level 2 - Wider gaps
            {
                platforms: [
                    { x: 0, y: 350, width: 800, height: 50 },
                    { x: 400, y: 250, width: 150, height: 20 },
                    { x: 100, y: 200, width: 150, height: 20 }
                ],
                coins: [
                    new Coin(450, 220),
                    new Coin(150, 170),
                    new Coin(500, 220)
                ],
                finishLine: { x: canvas.width - 60, y: 350 - 70, width: 10, height: 70 }
            }
        ];

        // Generate and add levels from 3 to 29
        for (let i = 3; i <= 29; i++) {
            levels.push(generateLevelData(i));
        }

        let currentLevelData = levels[0];
        let platforms = currentLevelData.platforms;
        let levelCoins = currentLevelData.coins;

        let keys = {};

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function nextLevel() {
            if (currentLevel < levels.length) {
                currentLevel++;
                levelDisplay.textContent = currentLevel;
                currentLevelData = levels[currentLevel - 1];
                platforms = currentLevelData.platforms;
                levelCoins = currentLevelData.coins.map(c => ({...c, collected: false})); // Reset coin collected state for the new level
                player.x = 50;
                player.y = 200;
                player.velocityY = 0;
                player.isJumping = false; // Reset jump state
            } else {
                // Optional: Handle game completion (e.g., display message)
                console.log("Game Complete!");
                alert("Congratulations! You've completed all levels!");
                // For now, just stop advancing, or could reset to level 1
                currentLevel = 1; // Optional: Restart game
                levelDisplay.textContent = currentLevel;
                currentLevelData = levels[0];
                platforms = currentLevelData.platforms;
                levelCoins = currentLevelData.coins.map(c => ({...c, collected: false}));
                player.x = 50;
                player.y = 200;

            }
        }

        function checkLevelComplete() {
            if (currentLevelData.finishLine && checkCollision(player, currentLevelData.finishLine)) {
                nextLevel();
            }
        }

        function collectCoins() {
            levelCoins.forEach(coin => {
                if (!coin.collected && checkCollision(player, coin)) {
                    coin.collected = true;
                    coins++;
                    coinDisplay.textContent = coins;
                }
            });
        }

        function update() {
            // Horizontal movement
            if (keys['ArrowLeft']) player.x -= player.speed;
            if (keys['ArrowRight']) player.x += player.speed;

            // Apply gravity
            player.velocityY += player.gravity;
            player.y += player.velocityY;

            // Check platform collisions
            let onPlatform = false;
            platforms.forEach(platform => {
                if (checkCollision(player, platform)) {
                    // Check if player is landing on top of the platform
                    if (player.velocityY > 0 && (player.y + player.height - player.velocityY) <= platform.y) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.isJumping = false;
                        onPlatform = true;
                    }
                    // Optional: Handle side collisions with platforms if needed
                     else if (player.y + player.height > platform.y + 5 && player.y < platform.y + platform.height -5) { // Side collision
                        if (keys['ArrowRight'] && player.x + player.width > platform.x && player.x < platform.x) {
                            player.x = platform.x - player.width;
                        } else if (keys['ArrowLeft'] && player.x < platform.x + platform.width && player.x + player.width > platform.x + platform.width) {
                            player.x = platform.x + platform.width;
                        }
                    }
                }
            });

            // Check coin collisions
            collectCoins();

            // Jump
            if (keys['ArrowUp'] && !player.isJumping && onPlatform) {
                player.velocityY = -player.jumpForce;
                player.isJumping = true;
            }

            // Keep player in bounds (horizontal)
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            
            // Keep player in bounds (vertical - bottom of canvas)
            // This also acts as a safety net if player falls off all platforms
            if (player.y + player.height > canvas.height) {
                player.y = canvas.height - player.height;
                player.velocityY = 0;
                player.isJumping = false;
                onPlatform = true; // Treat bottom of canvas as a platform for jumping
            }
            // Optional: Prevent player from going through top of canvas
            if (player.y < 0) {
                player.y = 0;
                player.velocityY = 0;
            }


            checkLevelComplete();
        }

        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw platforms
            ctx.fillStyle = '#4CAF50';
            platforms.forEach(platform => {
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            });

            // Draw coins
            ctx.fillStyle = 'gold';
            levelCoins.forEach(coin => {
                if (!coin.collected) {
                    ctx.beginPath();
                    ctx.arc(coin.x + coin.width/2, coin.y + coin.height/2, coin.width/2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw finish line
            if (currentLevelData.finishLine) {
                ctx.fillStyle = 'white'; // Color for the finish line pole
                ctx.fillRect(currentLevelData.finishLine.x, currentLevelData.finishLine.y, currentLevelData.finishLine.width, currentLevelData.finishLine.height);
                
                // Optional: Add a small flag on top
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.moveTo(currentLevelData.finishLine.x + currentLevelData.finishLine.width, currentLevelData.finishLine.y);
                ctx.lineTo(currentLevelData.finishLine.x + currentLevelData.finishLine.width + 20, currentLevelData.finishLine.y + 10);
                ctx.lineTo(currentLevelData.finishLine.x + currentLevelData.finishLine.width, currentLevelData.finishLine.y + 20);
                ctx.closePath();
                ctx.fill();
            }

            // Draw player
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
